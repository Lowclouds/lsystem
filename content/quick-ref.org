#+TITLE: L-System Explorer Quick Guide

* Modules
#+BEGIN_VERSE
Why are they called modules and not commands or something else?
Because module is an old term used by botanists for a unit of
growth (article in French from the Latin for branch and
translated to module in English.)

Modules marked *u* are *unimplemented*
Modules marked *p* are *partially implemented*
Modules marked *c* are *changed from TABOP/cpfg*
Modules marked *n* are *new for this implementation*
#+END_VERSE

** Turtle Motion
   Without a parameter move 'step' amount
|F(d) | move d units w/pen down, records track point|
|f(d) | move d units w/pen up, records track point|
|G(d) | ==== F(d), but does not record track points|
|g(d) | ==== f(d), w/o recording track points|
|@[Mm](x,y,z) | goto position, 'M' draw or 'm' don't draw |

** Turtle Orientation
#+BEGIN_VERSE
  The turtle maintains three unit vectors, heading (*H*), left (*L*), and up (*U*).
  The turtle home orientation is *H* = +x, *L* = +z, and *U* = +y,
  but L-system Explorer pitches up 90 degrees, initially, so *H* points +y and *L* points -x.

  A positive yaw (left) rotates *H* towards *L* around *U*.
  A positive pitch (down) rotates *U* towards *H* around *L*.
  A positive roll rotates *L* towards *U* around *H*.

  Without a parameter, a turn is 'delta' degrees; default is 90.

  *Note* We make the turtle behave as if it were in a right-handed system, but all the 
  underlying Babylonjs is left-handed. This has some odd consequences when comparing 
  models with TABOP. (If I'd known I could just tell Babylonjs to use a RHS, things 
  would have been simpler.)
#+END_VERSE
| +(a)                    | yaw left a degrees                           |
| -(a)                    | yaw right degrees                            |
| &(a)                    | pitch down a degrees                         |
| ^(a)                    | pitch up a degrees                           |
| \(a)                    | roll left a degrees                          |
| /(a)                    | roll right a degrees                         |
| \vert                   | yaw 180 degrees                              |
| @v                      | roll so U is parallel to up [y]              |
| @R(hx,hy,hz[,ux,uy,uz]) | set heading to [hx,hy,hz]                    |
|                         | set U parallel to [ux,uy,z], if supplied     |
| @H(h)               *n* | set turtle to home position and orientation, |
|                         | if optional h is not 0, then set H to +x,    |
|                         | otherwise, H is +y. Does not draw or record point |

** Turtle Settings
  Defaults without a parameter to one
| ;(i)       | increase or set color/material index           |
| ,(i)       | decrease or set color/material index           |
| @;(n)      | increase or set back face color/material index |
| @,(n)      | decrease or set back face color/material index |
| #(n)       | increase or set line width                     |
| !(n)       | decrease or set line width                     |
| @Tx(n) *u* | set texture index                              |
| @D(s) *u*  | set scale factor of subsequent geometry        |
| @Di(f) *u* | multiply scale factor by f                     |

** Turtle Geometry
| @o(d)            | circle of diameter d, centered at turtle position                 |
| @C(d) *u*        | circle of diameter d in HL plane                                  |
| @O(d)            | sphere of diameter d                                              |
| ~(S,s) *c*       | insert predefined surface S, with optional scale, s               |
| @Ds(n[,t]) *n*   | start contour with n final pts. t = 0 => open(default), 1 = closed  |
| @De(id) *n*      | end contour and save it as id (number or string)                  |
| @Da(t[,a]) *n*   | if t=0, create arc between previous 3 pts                         |
|                  | if t=1, create arc from previous two points, w/ctr at p0,         |
|                  | start at p1, with angle a                                         |
| @Dt(m1,m2) *n*   | create Hermite spline from previous two points, with optional |
|                  | length multipliers m1 and m2                                            |
| @Db              | Create a cubic Bezier spline segment from prior four points       |
| @Dm(m) *n*       | create contour of multiplicity m, default 1, only if closed type  |
| @#(id)           | set contour(id) as current track shape                            |
| {                | start polygon                                                     |
| }(n,S)           | end polygon of type n (possibly empty), optional save as mesh S   |
| {(0)  *c*        | start path with stepwise control pts, not polygon                 |
| {(1)             | start open path with Hermite spline control pts                   |
| {(2) *u*         | start closed path with Hermite spline control pts                 |
| {(3) *u*         | start open path with B-spline control pts                         |
| {(4) *u*         | start closed path with B-spline control pts                       |
| }[(id)] *p*      | end current path of any type and extrude contour, With            |
|                  | parameter, id, save path as mesh                                  |
| @Gs              | start Hermite spline path, same as '{(1).', i.e. saves point      |
| @Ge(n,id) *c*    | close path started with @Gs. if n, set # intermediate points.     |
|                  | If 'id', save extrusion as mesh                                   |
| .                | add current position to path, polygon, or contour                 |
| @Gt(m1,m2)       | Set tangent length multipliers - default is 1.2                   |
| @Gr(a1,l1,a2,l2) | Set slope and length of tangent vectors for radius curve          |
| @Gc(n)       *p* | Store control point. Optionally set number of interpolated strips |


** L-system Geometry and Control
| [               | start branch, pushing state onto stack    |
| ]               | end branch, popping branch state stack    |
| % *p*           | cut modules to end of branch              |
| $(id,scale) *c* | push current Lsystem and use sub-Lsystem id   |
| $               | end current sub-Lsystem, return to previous  |
  
* L-System Syntax
** Comments
   C-style comments, '/​* stuff, including newline */​' are supported.\\
   Single-line '//' style comments are not - they conflict with L-system syntax.
** Defines
   Lines that start with '#define macro value', 'macro' being some word, create
standard C-style macros where 'macro' is replaced with 'value' in 
the L-system before parsing starts.
** Settings
   Before the axiom is specified, variables can be set for the L-system. 
The following variables can be set to control default/initial L-system values, 
using standard syntax, i.e. var = value. Multiple settings on the same line must be
separated by a semi-colon.\\
   Note that the view setting is a JS object with the properties
'position' and 'target', whose values are JS arrays of X,Y,Z coordinates.
| stemsize | width of extrusion. default: 0.1                               |
| delta    | angle in degrees of yaw, pitch, and roll. default: 90          |
| step     | distance traveled by F,f,G,g modules. default: 1               |
| view     | position: 3D position of viewer/camera.                        |
|          | target: 3D position of view/camera target.                     |
|          | e.g. view = {position: [20,20,5], target: [0,8,0]}             |
|          | --- or ---                                                     |
|          | auto: direction                                                |
|          | where direction is one of X, -X, Y, -Y, Z, -Z, or              |
|          | a direction array defining where the camera position should    |
|          | be. The target is always the center of the bounding sphere     |
|          | of the drawn geometry and the distance from the target is      |
|          | twice the radius of the bounding sphere.                       |
|          | e.g. view = {auto: y} will look down on the XY plane. Note,    |
|          | case-insensitivity. Or,                                        |
|          | view = {auto: [1,1,1]} will place the camera on a line through |
|          | the target center parallel to the vector 1,1,1, looking at the |
|          | target                                                         |
|          | The default view is {auto: X}                                  |

   In addition, variables used in the L-system can be set and used in the L-system; they 
shouldn't conflict with any module parameters.
** Expressions
   Expressions occur in tests, parameters, and pre/post test *u*. They 
follow mathjs syntax: [[https://mathjs.org/docs/expressions/syntax.html][Expression syntax for mathjs]].

  Of particular note, are the logical operators which must be written explicitly as
| and | instead of '&&'|
| or | instead of '\vert\vert' |
| not | instead of '!' |
   e.g. (t > 0) and not u
* UI and controls
  - subject to constant change -
** Turtle controls
  At the top are the turtle controls. To the right of the label, "Turtle Controls" is a widget
  that will expand and collapse the controls. The first expansion is a buttonbar that controls the
  default turtle. If you open the Javascript console, you can directly enter Turtle3d commands to get 
  an idea for how it works. You can also turn on the Gen Code mode to get examples of how the turtle 
  is used. 

 - *Hide/Show* will hide or show the turtle shape, which is a mini axis of the HLU system of the turtle.
 - *Clear* will clear all the geometry generated by the turtle(s).
 - *Home* moves the turtle back to 0,0,0 and orients it along the axes.
 - *Reset* is the same as *Clear* and *Home*
 - *Look at Turtle* orients the camera so the turtle is in the center of view.
 - *Show/Hide Color Table* displays the current color/material table
 - *>* is a widget to expand a table that shows the position and heading of the turtle
** Scene Controls   
   Here you can toggle visibility of the Ground, Sky, and coordinate axes
** L-system controls
  Below the Turtle controls are the L-system controls. There is a link to this *Quick Ref*erence.
  The buttonbar and controls below that display and manipulate the lsystem and rendering of it.
  Since you need an L-system to use these, you can enter one manually in the text area below the Browse
  button, or use the Browse button to find a local L-system file. [Details later]

 - *Parse* this button will parse whatever text is in the L-system source area and show the result in the
   L-Ssytem Expansion text box. If you make changes to the L-system, choose this first.
 - *Rewrite* will rewrite the parsed L-system, and, again, place the result in the L-system Expansion box.
 - *Draw* will interpret the expanded system and draw the geometry on the canvas. Note, that *Draw* neither
  clears, homes, or resets any previously drawn geometry.
 - *Reset-and-Draw* will clear, and reset the turtle before drawing. It does not re-parse.
 - *Step* will do one interation step of the the L-system, no matter how many interations are specified in
  the L-system spec. As a special case, if the *Parse* button is used to clear and reparse the L-system, 
 - *Step* will initially write and interpret the axiom; subsequent steps will clear the previous geometry,
  rewrite one step of the L-system, and redraw it. This can be informative when multi-turtle mode is on and
  the draw speed is set low.
 - *MultiTurtle?* is a checkbox to turn this mode on/off. When on, the interpretation/drawing creates a new
  turtle for each branch and then gives each turtle one step on its branch in a round-robin draw mode. When
  a turtle reaches the end of the branch it is destroyed. This mode typically appears more natural.

 - *Choose File* allows you to load an lsystem locally. It is a text file, typically with a .ls extension
 - *Save* allows you to save the L-system

  Below the L-system source box are status and more controls:
 - *L-system status:* |X|Y|Z| , where X is the number of iterations/expansions of the axiom; Y is the number
  of modules in the L-system expansion, and Z is the number of modules that have been interpreted/drawn. This
  last box will turn green when drawing is complete.
 - *Draw Speed* is an input to control the drawing speed in modules/frame. It defaults to 200 and runs from
  1 to 500. Higher rates tend to bog down the browser.
 - *Save Mesh* allows you to save draw geometry to a GLTF file.
 - *Gen Code* causes the interpretation to generate the turtle code that it uses to draw the geometry. This 
  is simpler in single turtle mode.
 - *Save Code* allows you to save that generated code.
-----

